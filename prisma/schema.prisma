generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}
model User {
  id                   String            @id @default(uuid())
  email                String            @unique
  name                 String
  passwordHash         String
  phone                String?           @unique // For WhatsApp delivery
  phoneVerified        Boolean           @default(false) // OTP verification status
  role                 Role              @default(CREATOR)
  StripeCustomerId     String?           @unique
  createdAt            DateTime          @default(now())
  updatedAt            DateTime          @updatedAt
  contents             Content[]
  courses              Course[]
  notifications        Notification[]
  payments             Payment[]
  reviews              Review[]
  subscriptions        Subscription[]    @relation("UserSubscriptions")
  subscribers          Subscription[]    @relation("CreatorSubscriptions")
  profile              UserProfile?
  creatorConversations Conversation[]    @relation("CreatorConversations")
  fanConversations     Conversation[]    @relation("FanConversations")
  sentMessages         Message[]
  purchasedCourses     CourseAccess[] // New relation for course access
  contentDeliveries    ContentDelivery[]
  creatorProfile       CreatorProfile? // Added for relation to CreatorProfile
  like                 Like[]
  Comment              Comment[]
  tip                  Tip[]
  products             Product[]
  productReviews       ProductReview[]
  productSales         ProductSale[]

  // Community relations
  ownedCommunities     Community[]        @relation("CreatorCommunities")
  communityMemberships CommunityMember[]
  communityMessages    CommunityMessage[] @relation("CommunityMessages")

  @@index([name])
}

model UserProfile {
  id        String   @id @default(uuid())
  bio       String?
  avatarUrl String?
  website   String?
  twitter   String?
  instagram String?
  youtube   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id])
}

model Content {
  id               String             @id @default(uuid())
  title            String
  description      String?
  type             ContentType
  url              String
  status           ContentStatus      @default(DRAFT)
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  authorId         String
  courseId         String?
  categoryId       String?
  tagId            String?
  demoLink         String?
  language         String?
  metadata         String?
  notes            String?
  price            Float?             @default(0)
  tags             String?
  author           User               @relation(fields: [authorId], references: [id])
  Category         Category?          @relation(fields: [categoryId], references: [id])
  course           Course?            @relation(fields: [courseId], references: [id])
  Tag              Tag?               @relation(fields: [tagId], references: [id])
  ContentAnalytics ContentAnalytics[]
  community        Community? // Content-based community
}

model Course {
  id                String            @id @default(uuid())
  title             String
  description       String
  price             Float
  duration          Int
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  authorId          String
  salesCount        Int               @default(0)
  imgURL            String
  rating            Float
  contents          Content[]
  author            User              @relation(fields: [authorId], references: [id])
  lessons           Lesson[]
  reviews           Review[]
  courseAccess      CourseAccess[]
  contentDeliveries ContentDelivery[]
  payments Payment[]

  @@index([title])
  @@index([description])
  @@index([authorId])
}

model Lesson {
  id          String   @id @default(uuid())
  title       String
  description String
  order       Int
  contenturl  String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  courseId    String
  course      Course   @relation(fields: [courseId], references: [id])
}

model Subscription {
  id        String    @id @default(uuid())
  userId    String
  creatorId String
  createdAt DateTime  @default(now())
  payments  Payment[] // Added for relation to Payment

  user    User @relation("UserSubscriptions", fields: [userId], references: [id])
  creator User @relation("CreatorSubscriptions", fields: [creatorId], references: [id])

  @@unique([userId, creatorId]) // Prevent duplicate subscriptions
}

model Payment {
  id             String        @id @default(uuid())
  amount         Float
  currency       String        @default("INR")
  status         PaymentStatus
  paymentVia     String
  paymentId      String
  type PaymentType
  createdAt      DateTime      @default(now())
  subscriptionId String?
  subscription Subscription? @relation(fields: [subscriptionId], references: [id])
  postmediaId String? 
  postmedia PostMedia? @relation(fields: [postmediaId], references: [id])
  courseId String?
  course Course? @relation(fields: [courseId], references: [id])
  userId         String
  user           User          @relation(fields: [userId], references: [id])
}

model Review {
  id        String   @id @default(uuid())
  rating    Int
  comment   String?
  createdAt DateTime @default(now())
  userId    String
  courseId  String
  course    Course   @relation(fields: [courseId], references: [id])
  user      User     @relation(fields: [userId], references: [id])
}

model Category {
  id       String    @id @default(uuid())
  name     String    @unique
  contents Content[]
}

model Tag {
  id       String    @id @default(uuid())
  name     String    @unique
  contents Content[]
}

model ContentAnalytics {
  id         String    @id @default(uuid())
  views      Int       @default(0)
  likes      Int       @default(0)
  shares     Int       @default(0)
  lastviewed DateTime?
  contentId  String
  content    Content   @relation(fields: [contentId], references: [id])
}

model Notification {
  id        String           @id @default(uuid())
  type      NotificationType
  message   String
  read      Boolean          @default(false)
  createdAt DateTime         @default(now())
  userId    String
  user      User             @relation(fields: [userId], references: [id])
}

enum Role {
  ADMIN
  CREATOR
  CONSUMER
}

enum ContentType {
  VIDEO
  ARTICLE
  PODCAST
  COURSE
  TEMPLATE
  SOFTWARE
  EBOOK
  AUDIO
  IMAGE
  OTHER
}

enum ProductType {
  IMAGE
  VIDEO
  COURSE
  TEMPLATE
  SOFTWARE
  EBOOK
  AUDIO
  PHYSICAL
  OTHER
}

enum ContentStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED
  PAUSED
  EXPIRED
}

enum PaymentStatus {
  SUCCEEDED
  PENDING
  FAILED
  REFUNDED
}

enum NotificationType {
  SYSTEM
  PAYMENT
  CONTENT
  SUBSCRIPTION
  COMMUNITY
}

enum PaymentType {
  SUBSCRIPTION
  POST_MEDIA_UNLOCK
  COURSE
}

model Community {
  id          String  @id @default(uuid())
  name        String
  description String?
  type        String // "CONTENT_COMMUNITY" or "SUBSCRIPTION_COMMUNITY"
  maxMembers  Int     @default(1000)

  // References
  contentId String? // For content-based communities
  creatorId String // Creator who owns this community

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  creator      User                   @relation("CreatorCommunities", fields: [creatorId], references: [id])
  content      Content?               @relation(fields: [contentId], references: [id])
  members      CommunityMember[]
  conversation CommunityConversation?

  @@unique([contentId]) // One community per content
  @@unique([creatorId, type]) // One subscription community per creator
  @@index([creatorId, type])
}

model CommunityMember {
  id         String    @id @default(uuid())
  joinedAt   DateTime  @default(now())
  lastActive DateTime?
  lastReadAt DateTime  @default(now())

  // References
  userId      String
  communityId String

  // Relations
  user      User      @relation(fields: [userId], references: [id])
  community Community @relation(fields: [communityId], references: [id], onDelete: Cascade)

  @@unique([userId, communityId]) // One membership per user per community
  @@index([communityId])
  @@index([userId])
}

// Direct conversations (1-on-1) - keeping the original name for compatibility
model Conversation {
  id            String   @id @default(uuid())
  creatorId     String
  fanId         String
  lastMessageAt DateTime @default(now())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  creator  User      @relation("CreatorConversations", fields: [creatorId], references: [id])
  fan      User      @relation("FanConversations", fields: [fanId], references: [id])
  messages Message[]

  @@unique([creatorId, fanId])
  @@index([creatorId, lastMessageAt])
}

// Community conversations (group chat)
model CommunityConversation {
  id            String   @id @default(uuid())
  communityId   String   @unique
  lastMessageAt DateTime @default(now())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  community Community          @relation(fields: [communityId], references: [id])
  messages  CommunityMessage[]
}

// Direct messages (1-on-1) - keeping the original name for compatibility
model Message {
  id        String   @id @default(uuid())
  content   String
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // References
  conversationId String
  senderId       String

  // Relations
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User         @relation(fields: [senderId], references: [id])

  @@index([conversationId, createdAt])
  @@index([senderId])
}

// Community messages (group chat)
model CommunityMessage {
  id        String   @id @default(uuid())
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // References
  conversationId String
  senderId       String

  // Relations
  conversation CommunityConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User                  @relation("CommunityMessages", fields: [senderId], references: [id])

  @@index([conversationId, createdAt])
  @@index([senderId])
}

model CourseAccess {
  id               String    @id @default(uuid())
  userId           String
  courseId         String
  purchaseDate     DateTime  @default(now())
  deliveryMethod   String? // 'WHATSAPP', 'EMAIL', 'APP_ONLY'
  deliveryStatus   String    @default("PENDING") // 'PENDING', 'SENT', 'DELIVERED', 'FAILED'
  accessExpiryDate DateTime?
  createdAt        DateTime  @default(now())

  user   User   @relation(fields: [userId], references: [id])
  course Course @relation(fields: [courseId], references: [id])

  @@unique([userId, courseId])
  @@index([userId])
}

model OTPVerification {
  id        String   @id @default(uuid())
  phone     String
  otp       String
  purpose   String // 'PHONE_VERIFICATION', 'COURSE_DELIVERY'
  expiresAt DateTime
  verified  Boolean  @default(false)
  attempts  Int      @default(0)
  createdAt DateTime @default(now())

  @@index([phone, purpose])
}

model ContentDelivery {
  id               String    @id @default(uuid())
  courseId         String
  userId           String
  contentType      String
  deliveryMethod   String // 'WHATSAPP', 'EMAIL'
  recipientContact String // Phone or email
  status           String    @default("PENDING") // 'PENDING', 'SENT', 'DELIVERED', 'FAILED'
  deliveredAt      DateTime?
  errorMessage     String?
  retryCount       Int       @default(0)
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  course Course @relation(fields: [courseId], references: [id])
  user   User   @relation(fields: [userId], references: [id])

  @@index([status, createdAt])
}

// --- Membership & Subscription Models Start ---
model CreatorProfile {
  id                String  @id @default(uuid())
  user              User    @relation(fields: [userId], references: [id])
  userId            String  @unique
  isPaid            Boolean @default(false)
  IsLive            Boolean @default(false)
  subscriptionPrice Int?
  posts             Post[]
}

model Post {
  id         String         @id @default(uuid())
  title      String
  content    String
  isPaidOnly Boolean        @default(false)
  creator    CreatorProfile @relation(fields: [creatorId], references: [id])
  creatorId  String
  createdAt  DateTime       @default(now())
  likes      Like[]
  comments   Comment[]
  media      PostMedia[]
  tip        Tip[]
}

model PostMedia {
  id         String   @id @default(uuid())
  url        String
  type       String // "photo" or "video"
  LikesCount Int      @default(0)
  post       Post     @relation(fields: [postId], references: [id])
  postId     String
  createdAt  DateTime @default(now())
  payments Payment[]
}

model Like {
  id     String @id @default(uuid())
  user   User   @relation(fields: [userId], references: [id])
  userId String
  post   Post   @relation(fields: [postId], references: [id])
  postId String

  @@unique([userId, postId]) // one like per user per post
}

model Comment {
  id        String   @id @default(uuid())
  content   String
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  post      Post     @relation(fields: [postId], references: [id])
  postId    String
  createdAt DateTime @default(now())
}

// --- Membership & Subscription Models End ---

model Tip {
  id        String   @id @default(uuid())
  postId    String
  userId    String
  amount    Int
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id])
  post      Post     @relation(fields: [postId], references: [id])

  @@index([postId])
  @@index([userId])
}

model Product {
  id          String      @id @default(uuid())
  title       String
  description String?
  price       Float
  type        ProductType
  thumbnail   String?
  status      ProductStatus @default(DRAFT)
  rating      Float       @default(0)
  salesCount  Int         @default(0)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  
  // Relations
  creatorId   String
  creator     User        @relation(fields: [creatorId], references: [id])
  categoryId  String?
  category    ProductCategory? @relation(fields: [categoryId], references: [id])
  reviews     ProductReview[]
  sales       ProductSale[]
  
  @@index([creatorId])
  @@index([type])
  @@index([status])
  @@index([rating])
}

model ProductCategory {
  id          String    @id @default(uuid())
  name        String    @unique
  description String?
  createdAt   DateTime  @default(now())
  
  // Relations
  products    Product[]
}

model ProductReview {
  id        String   @id @default(uuid())
  rating    Int
  comment   String?
  createdAt DateTime @default(now())
  
  // Relations
  productId String
  product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  
  @@unique([userId, productId]) // One review per user per product
  @@index([productId])
}

model ProductSale {
  id        String   @id @default(uuid())
  amount    Float
  currency  String   @default("INR")
  status    PaymentStatus
  createdAt DateTime @default(now())
  
  // Relations
  productId String
  product   Product  @relation(fields: [productId], references: [id])
  buyerId   String
  buyer     User     @relation(fields: [buyerId], references: [id])
  
  @@index([productId])
  @@index([buyerId])
}

enum ProductStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}
